<style is:inline>
  :root {
    --tile-size: clamp(2.5rem, 4vw, 5rem);
  }

  .game-wrapper {
    padding: 16px;
    border-radius: 20px;
    background-color: #f9f9f9;
  }
  .grid {
    display: grid;
    grid-template-columns: repeat(5, 0.2fr);
    gap: 5px;
  }
  .cell {
    width: var(--tile-size);
    height: var(--tile-size);
    border: 1px solid #cecece;
    cursor: pointer;
    border-radius: 4px;
    position: relative;
    background: radial-gradient(circle, #ff6666 30%, #cc0000 100%);
  }
  .cell::after {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: 2px;
    background: rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(6px);
    opacity: 0.5;
  }
  .off {
    background: radial-gradient(circle, #e3dfe6 30%, #8e8c99 100%);
  }
  .controls {
    padding-top: 8px;
  }
</style>

<div
  class="flex min-h-dvh w-full flex-col items-center justify-center bg-gray-200"
>
  <div class="game-wrapper">
    <div class="grid"></div>
    <div class="controls">
      <button
        class="inline-flex min-h-[2.5rem] items-center justify-center gap-2 rounded bg-black px-6 text-white"
        onclick="displaySolution()">Solve</button
      >
      <button
        class="inline-flex min-h-[2.5rem] items-center justify-center gap-2 rounded bg-black px-6 text-white"
        onclick="resetGame()">Reset</button
      >
    </div>
  </div>

  <p id="statusText"></p>
  <p id="solution"></p>
</div>

<script is:inline>
  const gridSize = 5;
  const grid = document.querySelector(".grid");
  const statusText = document.getElementById("statusText");
  const solutionText = document.getElementById("solution");
  let board;

  function resetGame() {
    board = Array.from({ length: gridSize }, () => Array(gridSize).fill(0));

    // Generate a solvable board by applying a sequence of random valid moves to an empty board
    for (let i = 0; i < gridSize * gridSize; i++) {
      if (Math.random() > 0.5) {
        toggleLights(Math.floor(i / gridSize), i % gridSize, false);
      }
    }
    statusText.innerHTML = "";
    solutionText.innerHTML = "";
    createGrid();
  }

  function createGrid() {
    grid.innerHTML = "";
    for (let row = 0; row < gridSize; row++) {
      for (let col = 0; col < gridSize; col++) {
        const cell = document.createElement("div");
        cell.classList.add("cell");
        if (!board[row][col]) cell.classList.add("off");
        cell.dataset.row = row;
        cell.dataset.col = col;
        cell.addEventListener("click", () => toggleLights(row, col, true));
        grid.appendChild(cell);
      }
    }
  }

  function toggleLights(row, col, checkWin = true) {
    const toggle = (r, c) => {
      if (r >= 0 && r < gridSize && c >= 0 && c < gridSize) {
        board[r][c] = board[r][c] ? 0 : 1;
      }
    };
    toggle(row, col);
    toggle(row - 1, col);
    toggle(row + 1, col);
    toggle(row, col - 1);
    toggle(row, col + 1);
    if (checkWin) checkWinCondition();
    createGrid();
  }

  function checkWinCondition() {
    if (board.flat().every((cell) => cell === 0)) {
      statusText.textContent = "You win!";
    } else {
      statusText.textContent = "";
    }
  }

  function displaySolution() {
    let solution = solveLightsOut(board);
    if (solution.length > 0) {
      solutionText.innerHTML =
        "Solution steps: " +
        solution.map(([r, c]) => r * gridSize + c + 1).join(", ");
    } else {
      solutionText.innerHTML = "No solution found.";
    }
  }

  function solveLightsOut(board) {
    let matrix = Array.from({ length: gridSize * gridSize }, () =>
      Array(gridSize * gridSize + 1).fill(0),
    );

    for (let r = 0; r < gridSize; r++) {
      for (let c = 0; c < gridSize; c++) {
        let idx = r * gridSize + c;
        matrix[idx][idx] = 1;
        if (r > 0) matrix[idx - gridSize][idx] = 1;
        if (r < gridSize - 1) matrix[idx + gridSize][idx] = 1;
        if (c > 0) matrix[idx - 1][idx] = 1;
        if (c < gridSize - 1) matrix[idx + 1][idx] = 1;
        matrix[idx][gridSize * gridSize] = board[r][c];
      }
    }

    for (let i = 0; i < gridSize * gridSize; i++) {
      if (matrix[i][i] === 0) {
        for (let j = i + 1; j < gridSize * gridSize; j++) {
          if (matrix[j][i] === 1) {
            [matrix[i], matrix[j]] = [matrix[j], matrix[i]];
            break;
          }
        }
      }
      for (let j = i + 1; j < gridSize * gridSize; j++) {
        if (matrix[j][i] === 1) {
          for (let k = 0; k <= gridSize * gridSize; k++) {
            matrix[j][k] ^= matrix[i][k];
          }
        }
      }
    }

    let solution = [];
    for (let i = gridSize * gridSize - 1; i >= 0; i--) {
      if (matrix[i][i] === 1) {
        let sum = matrix[i][gridSize * gridSize];
        for (let j = i + 1; j < gridSize * gridSize; j++) {
          sum ^= matrix[i][j] * matrix[j][gridSize * gridSize];
        }
        matrix[i][gridSize * gridSize] = sum;
        if (sum) solution.push([Math.floor(i / gridSize), i % gridSize]);
      }
    }
    return solution;
  }

  resetGame();
</script>
